import {CacheType, Client, Interaction, ModalSubmitInteraction, TextChannel} from "discord.js";
import {aide} from "../commands/aide";
import {info} from "../commands/info";
import {wifi} from "../commands/wifi";

export enum ECommandType {
    COMMAND = "COMMAND",
    BUTTON = "BUTTON"
}

export const interactionLaunch = async (interaction: any | Interaction<CacheType> | ModalSubmitInteraction<CacheType>, client: Client, version: string, callDate: Date, uptime: Date): Promise<void> => {
    const commandType = interaction.isCommand() ? ECommandType.COMMAND : ECommandType.BUTTON;
    const commandName = commandType == ECommandType.COMMAND ?
        interaction.commandName.toUpperCase() : interaction.customId.toUpperCase();
    
    try {
        switch (commandName) {
            case 'AIDE':
                return await aide({interaction: interaction, version: version});
            case 'INFO':
                return await info({interaction: interaction, version: version, time: callDate, botUptime: uptime});
            case 'WIFI':
                return await wifi({interaction: interaction, version: version});
            // case 'EDT':
            //     return await edt({ num: interaction.options.get('semaine').value, interaction: interaction, client: client, type: commandType });
            // case 'EDT1':
            //     return await edt({ num: '1', interaction: interaction, client: client, type: commandType });
            // case 'EDT2':
            //     return await edt({ num: '2', interaction: interaction, client: client, type: commandType });
            // case 'EDT3':
            //     return await edt({ num: '3', interaction: interaction, client: client, type: commandType });
            // case 'DEV':
            //     return await devoir({ interaction: interaction, client: client, version: version, type: commandType });
            // case 'DEVOIRS':
            //     if (interaction.options._subcommand == "afficher") {
            //         return await devoir({ interaction: interaction, client: client, version: version, type: commandType });
            //     } else if (interaction.options._subcommand == "forceadd") {
            //         return await forceAddDevoir({ interaction: interaction, client: client });
            //     } else if (interaction.options._subcommand == "forcedelete") {
            //         return await forceDeleteDevoir({ interaction: interaction, client: client });
            //     } else {
            //         return await addDevoir({ interaction: interaction, client: client });
            //     }
            // case 'STATS':
            //     if (interaction.options?._subcommand == "devoirs") {
            //         return await devstats({ interaction: interaction, version: version });
            //     }
            //     return await stats({ interaction: interaction, client: client, version: version, type: commandType });
            // case 'DEVSTATS':
            //     return await devstats({ interaction: interaction, version: version });
            // PRIVATE
            case 'ESI':
            // return await sendBIEMessage({ interaction: interaction, client: client });
            default:
                return await interaction?.deferUpdate();
        }
    } catch (err: any) {
        const chan = client.channels.cache.get(process.env.CHNL_ERROR);
        if (chan instanceof TextChannel) chan.send(`Error CMD[${commandName}|${commandType}] was generated by <@${interaction.author?.id}>-${interaction.author?.id}-${interaction.author?.username}#${interaction.author?.discriminator}\n\`\`\`${err}\`\`\``).catch(() => {
        
        });
        console.error(`Error CMD[${commandName}|${commandType}] was generated by <@${interaction.author?.id}>-${interaction.author?.id}-${interaction.author?.username}#${interaction.author?.discriminator}:`, err);
    }
};